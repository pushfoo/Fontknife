"""
Functionality common to multiple formats.

This file contains baseclasses for both readers and writers
for convenience, and to make it easier to understand how to
write format plugins.
"""
from abc import ABC, abstractmethod
from pathlib import Path
from typing import Dict, Type, Set, Callable, Union, Optional, Iterable, Any

from octofont3.custom_types import PathLike, HasRead, PathLikeOrHasRead, PathLikeOrHasWrite
from octofont3.iohelpers import get_resource_filesystem_path, SeekableBinaryFileCopy
from octofont3.formats.common.caching import get_cache, load_and_cache_bitmap_font
from octofont3.formats.common.raster_font import RasterFont, copy_glyphs


class FormatReader(ABC):

    # Track valid readers in subclasses
    by_format_name: Dict[str, Type["FormatReader"]] = {}
    by_file_extension: Dict[str, Type["FormatReader"]] = {}
    file_extension_to_format_name: Dict[str, str] = {}
    file_extensions_for_class: Dict[type, Set[str]] = {}

    def __init__(self, caching_strategy: Callable = get_cache):
        """
        Baseclass for all format readers.

        These classes handle loading from a file to a RasterFont.
        :param caching_strategy:
        """
        self.cache = caching_strategy()

    def __init_subclass__(cls):
        """
        Registers every subclass without ABC as an immediate parent.

        This uses the attributes of subclasses instead of
        __init_subclass__ arguments because ABC appears to be
        incompatible with them in current python versions.

        The following optional subclass attributes are supported:
            1. ``wrapped_creation_func``: a creation function or type
               wrapped by the subclass.
            1. ``format_name``: overrides auto-generation of format name
            2. ``file_extension``: overrides auto-generation of file
                extensions.

        If ``format_name`` is None or empty, it will be generated by:

            1. Converting the class name to lower case
            2. Removing 'reader' from the end of the name if present

        ``file_extensions`` will be handled as follows:

            1. Use the ``file_extensions`` class attribute if it
               exists, otherwise use the format name.
            2. If the current candidate is a string, use it to create
               a 1-length set. Otherwise, convert the iterable to a
               set.
            3. Use the set to fill ``by_file_extension`` and
               ``file_extensions_for_class``.

        The reader classes can then be retrieved by their associated
        format names and file extensions.
       """

        # Don't register classes with ABC as a direct baseclass. This
        # allows excluding intermediate reader classes without adding
        # extra abstract methods or properties for isabstract to detect.
        if ABC in cls.__bases__:
            return

        # If wrapped_creation_func is defined, type check it
        wrapped = getattr(cls, 'wrapped_creation_func', None)
        if wrapped is not None and not callable(wrapped):
            raise TypeError('wrapped_creation_func must be a type or factory method for non-abstract classes!')

        # Use a specified format_name or generate one from the class
        format_name = getattr(cls, 'format_name', None)
        if not format_name:
            format_name = cls.__name__.lower().replace('reader', '')
        cls.by_format_name[format_name] = cls

        # Use format_name as an extension if no extensions are specified
        file_extensions = getattr(cls, 'file_extensions', None)
        if not file_extensions:
            file_extensions = (format_name,)
        if isinstance(file_extensions, str):
            file_extensions = (file_extensions,)
        file_extensions = set(file_extensions)

        # Register the format_name and extensions for the reader
        cls.file_extensions_for_class[cls] = file_extensions
        for extension in file_extensions:
            cls.by_file_extension[extension] = cls
            cls.file_extension_to_format_name[extension] = format_name

    @abstractmethod
    def load_source(
            self, source: Union[PathLike, HasRead],
            force_provided_glyphs: Optional[Iterable[str]] = None
    ) -> RasterFont:
        pass


class FormatWriter(ABC):

    # Track valid writers in subclasses
    by_format_name: Dict[str, Type["FormatWriter"]] = {}
    by_file_extension: Dict[str, Type["FormatWriter"]] = {}
    file_extension_to_format_name: Dict[str, str] = {}
    file_extensions_for_class: Dict[type, Set[str]] = {}

    def __init__(self):
        pass

    def __init_subclass__(cls):
        """
        Registers every subclass without ABC as an immediate parent.

        This uses the attributes of subclasses instead of
        __init_subclass__ arguments because ABC appears to be
        incompatible with them in current python versions.

        The following optional subclass attributes are supported:
            1. ``wrapped_write_func``: a creation function or type
               wrapped by the subclass.
            1. ``format_name``: overrides auto-generation of format name
            2. ``file_extension``: overrides auto-generation of file
                extensions.

        If ``format_name`` is None or empty, it will be generated by:

            1. Converting the class name to lower case
            2. Removing 'reader' from the end of the name if present

        ``file_extensions`` will be handled as follows:

            1. Use the ``file_extensions`` class attribute if it
               exists, otherwise use the format name.
            2. If the current candidate is a string, use it to create
               a 1-length set. Otherwise, convert the iterable to a
               set.
            3. Use the set to fill ``by_file_extension`` and
               ``file_extensions_for_class``.

        The writer classes can then be retrieved by their associated
        format names and file extensions.
       """

        # Don't register classes with ABC as a direct baseclass. This
        # allows excluding intermediate reader classes without adding
        # extra abstract methods or properties for isabstract to detect.
        if ABC in cls.__bases__:
            return

        # If wrapped_write_func is defined, type check it
        wrapped = getattr(cls, 'wrapped_write_func', None)
        if wrapped is not None and not callable(wrapped):
            raise TypeError('wrapped_write_func must be callable if present!')

        # Use a specified format_name or generate one from the class
        format_name = getattr(cls, 'format_name', None)
        if not format_name:
            format_name = cls.__name__.lower().replace('writer', '')
        cls.by_format_name[format_name] = cls

        # Use format_name as an extension if no extensions are specified
        file_extensions = getattr(cls, 'file_extensions', None)
        if not file_extensions:
            file_extensions = (format_name,)
        if isinstance(file_extensions, str):
            file_extensions = (file_extensions,)
        file_extensions = set(file_extensions)

        # Register the format_name and extensions for the reader
        cls.file_extensions_for_class[cls] = file_extensions
        for extension in file_extensions:
            cls.by_file_extension[extension] = cls
            cls.file_extension_to_format_name[extension] = format_name

    @abstractmethod
    def write_output(
        self,
        font: RasterFont,
        destination: PathLikeOrHasWrite,
        glyph_sequence: Optional[Iterable[str]] = None
    ) -> RasterFont:
        pass


def guess_source_path_type(path: Optional[PathLike]) -> Optional[str]:

    if path is None:
        return None

    path = Path(path)
    if not path.suffix:
        return 'spritedir' if path.is_dir() else None

    extension = path.suffix[1:]
    path_type = FormatReader.file_extension_to_format_name.get(extension, None)
    return path_type


def guess_source_type(source: PathLikeOrHasRead) -> Optional[str]:
    source_path = get_resource_filesystem_path(source)
    source_type = guess_source_path_type(source_path)
    return source_type


def guess_output_path_type(path: Optional[PathLike]) -> Optional[str]:
    if path is None:
        return None

    path = Path(path)
    if not path.suffix:
        return 'spritedir' if path.is_dir() else None

    extension = path.suffix[1:]
    path_type = FormatWriter.file_extension_to_format_name.get(extension, None)
    return path_type


def guess_output_type(output: PathLikeOrHasWrite) -> Optional[str]:
    output_path = get_resource_filesystem_path(output)
    output_type = guess_output_path_type(output_path)
    return output_type


class BinaryReader(FormatReader, ABC):
    wrapped_creation_func: Optional[type] = None


class CachingReader(BinaryReader, ABC):

    def load_source(
            self,
            source: Union[PathLike, HasRead],
            font_size: int = 16,
            provided_glyphs: Optional[Iterable[str]] = None
    ) -> RasterFont:
        stream = SeekableBinaryFileCopy.copy(source)
        original_path = stream.filename

        raw_font = load_and_cache_bitmap_font(
            source, self.wrapped_creation_func, cache=self.cache)
        actual_path = getattr(raw_font, 'file')
        provided_glyphs = self.cache[original_path].provided_glyphs
        raw_glyphs = copy_glyphs(raw_font, provided_glyphs)
        result = RasterFont(raw_glyphs, size_points=font_size, path=actual_path)
        return result


class FontFormatError(Exception, ABC):

    def __init__(
        self,
        path: Optional[PathLike] = None,
        format_name: Optional[Any] = None,
        message: Optional[str] = None
    ):
        super().__init__(message or self._gen_message(path, format_name))
        self.path = path

    @abstractmethod
    def _gen_message(self, path, source_type) -> str:
        ...


class FontFormatLoadingError(FontFormatError, ABC):
    pass


class FontFormatWritingError(FontFormatError, ABC):
    pass


class UnclearSourceFontFormat(FontFormatError):

    def _gen_message(self, path, source_type) -> str:
        return f"Could not resolve a source font format for {path!r}. Please specify it directly."


class UnclearOutputFontFormat(FontFormatWritingError):
    def _gen_message(self, path, source_type) -> str:
        return f"Could not resolve an output font format for {path!r}. Please specify it directly."


class PipingFromStdinRequiresFontFormat(UnclearSourceFontFormat):

    def _gen_message(self, path, source_type) -> str:
        return "You must specify a source type when piping from stdin."


class PipingToStdoutRequiresFontFormat(UnclearSourceFontFormat):

    def _gen_message(self, path, source_type) -> str:
        return "You must specify an source type when piping from stdin."


class FontFormatRequiresGlyphSequence(FontFormatError):

    def _gen_message(self, path, source_type) -> str:
        return f"Specifying glyphs sequence is mandatory for {source_type!r}"