"""
Functionality common to multiple formats.

This file contains baseclasses for both readers and writers
for convenience, and to make it easier to understand how to
write format plugins.
"""
from abc import ABC, abstractmethod
from pathlib import Path
from typing import Dict, Type, Set, Callable, Union, Optional, Iterable

from octofont3.custom_types import PathLike, HasRead, PathLikeOrHasRead
from octofont3.iohelpers import get_source_filesystem_path, SeekableBinaryFileCopy
from octofont3.formats.common.caching import get_cache, load_and_cache_bitmap_font
from octofont3.formats.common.raster_font import RasterFont, copy_glyphs


class FormatReader(ABC):

    # Track valid readers in subclasses
    by_format_name: Dict[str, Type["FormatReader"]] = {}
    by_file_extension: Dict[str, Type["FormatReader"]] = {}
    file_extension_to_format_name: Dict[str, str] = {}
    file_extensions_for_class: Dict[type, Set[str]] = {}

    def __init__(self, caching_strategy: Callable = get_cache):
        """
        Baseclass for all format readers.

        These classes handle loading from a file to a RasterFont.
        :param caching_strategy:
        """
        self.cache = caching_strategy()

    def __init_subclass__(cls):
        """
        Registers every subclass without ABC as an immediate parent.

        This uses the attributes of subclasses instead of
        __init_subclass__ arguments because ABC appears to be
        incompatible with them in current python versions.

        The following optional subclass attributes are supported:
            1. ``wrapped_creation_func``. A creation function or type
               wrapped by the subclass.
            1. ``format_name`` overrides auto-generation of format name
            2. ``file_extension`` overrides auto-generation of file
                extensions.

        If ``format_name`` is None or empty, it will be generated by:

            1. Converting the class name to lower case
            2. Removing 'reader' from the end of the name if present

        ``file_extensions`` will be handled as follows:

            1. Use the ``file_extensions`` class attribute if it
               exists, otherwise use the format name.
            2. If the current candidate is a string, use it to create
               a 1-length set. Otherwise, convert the iterable to a
               set.
            3. Use the set to fill ``by_file_extension`` and
               ``file_extensions_for_class``.

        The reader classes can then be retrieved by their associated
        format names and file extensions.
       """

        # Don't register classes with ABC as a direct baseclass. This
        # allows excluding intermediate reader classes without adding
        # extra abstract methods or properties for isabstract to detect.
        if ABC in cls.__bases__:
            return

        # If wrapped_creation_func is defined, type check it
        wrapped = getattr(cls, 'wrapped_creation_func', None)
        if wrapped is not None and not callable(wrapped):
           raise TypeError('wrapped_creation_func must be a type or factory method for non-abstract classes!')

        # Use a specified format_name or generate one from the class
        format_name = getattr(cls, 'format_name', None)
        if not format_name:
            format_name = cls.__name__.lower().replace('reader', '')
        cls.by_format_name[format_name] = cls

        # Use format_name as an extension if no extensions are specified
        file_extensions = getattr(cls, 'file_extensions', None)
        if not file_extensions:
            file_extensions = (format_name,)
        if isinstance(file_extensions, str):
            file_extensions = (file_extensions,)
        file_extensions = set(file_extensions)

        # Register the format_name and extensions for the reader
        cls.file_extensions_for_class[cls] = file_extensions
        for extension in file_extensions:
            cls.by_file_extension[extension] = cls
            cls.file_extension_to_format_name[extension] = format_name

    @abstractmethod
    def load_source(
            self, source: Union[PathLike, HasRead],
            force_provided_glyphs: Optional[Iterable[str]] = None
    ) -> RasterFont:
        pass


def guess_path_type(path: Optional[PathLike]) -> Optional[str]:
    if path is None:
        return None

    path = Path(path)
    if not path.suffix:
        return 'spritedir' if path.is_dir() else None

    extension = path.suffix[1:]
    path_type = FormatReader.file_extension_to_format_name.get(extension, None)
    return path_type


def guess_source_path_type(source: PathLikeOrHasRead) -> Optional[str]:
    source_path = get_source_filesystem_path(source)
    source_type = guess_path_type(source_path)
    return source_type


class BinaryReader(FormatReader, ABC):
    wrapped_creation_func: Optional[type] = None


class CachingReader(BinaryReader, ABC):

    def load_source(
            self,
            source: Union[PathLike, HasRead],
            font_size: int = 16,
            provided_glyphs: Optional[Iterable[str]] = None
    ) -> RasterFont:
        stream = SeekableBinaryFileCopy.copy(source)
        original_path = stream.filename

        raw_font = load_and_cache_bitmap_font(
            source, self.wrapped_creation_func, cache=self.cache)
        actual_path = getattr(raw_font, 'file')
        provided_glyphs = self.cache[original_path].provided_glyphs
        raw_glyphs = copy_glyphs(raw_font, provided_glyphs)
        result = RasterFont(raw_glyphs, size_points=font_size, path=actual_path)
        return result
