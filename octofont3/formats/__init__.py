from abc import ABC, abstractmethod
from pathlib import Path
from typing import Optional, Iterable, Union, Callable, Dict, Set, Type

from PIL import ImageFont
from PIL.BdfFontFile import BdfFontFile
from PIL.PcfFontFile import PcfFontFile

from octofont3.custom_types import HasRead, PathLike, PathLikeOrHasRead
from octofont3.formats.raster_font import copy_glyphs, RasterFont
from octofont3.formats.caching import get_cache, load_and_cache_bitmap_font
from octofont3.formats.raster_font import copy_glyphs, RasterFont
from octofont3.formats.textfont.parser import TextFontFile
from octofont3.iohelpers import SeekableBinaryFileCopy, get_source_filesystem_path, StdOrFile
from octofont3.utils import generate_glyph_sequence


class FormatReader(ABC):

    # Track valid readers in subclasses
    by_format_name: Dict[str, Type["FormatReader"]] = {}
    by_file_extension: Dict[str, Type["FormatReader"]] = {}
    file_extension_to_format_name: Dict[str, str] = {}
    file_extensions_for_class: Dict[type, Set[str]] = {}

    def __init__(self, caching_strategy: Callable = get_cache):
        """
        Baseclass for all format readers.

        These classes handle loading
        :param caching_strategy:
        """
        self.cache = caching_strategy()

    def __init_subclass__(cls):
        """
        Register every subclass without ABC as an immediate parent.

        This uses the attributes of subclasses instead of
        __init_subclass__ arguments because ABC appears to be
        incompatible with them in current python versions.

        The following optional subclass attributes are supported:
            1. ``wrapped_creation_func``. A creation function or type
               wrapped by the subclass.
            1. ``format_name`` overrides auto-generation of format name
            2. ``file_extension`` overrides auto-generation of file
                extensions.

        If ``format_name`` is None or empty, it will be generated by:

            1. Converting the class name to lower case
            2. Removing 'reader' from the end of the name if present

        ``file_extensions`` will be handled as follows:

            1. Use the ``file_extensions`` class attribute if it
               exists, otherwise use the format name.
            2. If the current candidate is a string, use it to create
               a 1-length set. Otherwise, convert the iterable to a
               set.
            3. Use the set to fill ``by_file_extension`` and
               ``file_extensions_for_class``.

        The reader classes can then be retrieved by their associated
        format names and file extensions.
       """

        # Don't register classes with ABC as a direct baseclass. This
        # allows excluding intermediate reader classes without adding
        # extra abstract methods or properties for isabstract to detect.
        if ABC in cls.__bases__:
            return

        # If wrapped_creation_func is defined, type check it
        wrapped = getattr(cls, 'wrapped_creation_func', None)
        if wrapped is not None and not callable(wrapped):
           raise TypeError('wrapped_creation_func must be a type or factory method for non-abstract classes!')

        # Use a specified format_name or generate one from the class
        format_name = getattr(cls, 'format_name', None)
        if not format_name:
            format_name = cls.__name__.lower().replace('reader', '')
        cls.by_format_name[format_name] = cls

        # Use format_name as an extension if no extensions are specified
        file_extensions = getattr(cls, 'file_extensions', None)
        if not file_extensions:
            file_extensions = (format_name,)
        if isinstance(file_extensions, str):
            file_extensions = (file_extensions,)
        file_extensions = set(file_extensions)

        # Register the format_name and extensions for the reader
        cls.file_extensions_for_class[cls] = file_extensions
        for extension in file_extensions:
            cls.by_file_extension[extension] = cls
            cls.file_extension_to_format_name[extension] = format_name

    @abstractmethod
    def load_source(
            self, source: Union[PathLike, HasRead],
            force_provided_glyphs: Optional[Iterable[str]] = None
    ) -> RasterFont:
        pass


def guess_path_type(path: Optional[PathLike]) -> Optional[str]:
    if path is None:
        return None

    path = Path(path)
    if not path.suffix:
        return 'spritedir' if path.is_dir() else None

    extension = path.suffix[1:]
    path_type = FormatReader.file_extension_to_format_name.get(extension, None)
    return path_type


def guess_source_path_type(source: PathLikeOrHasRead) -> Optional[str]:
    source_path = get_source_filesystem_path(source)
    source_type = guess_path_type(source_path)
    return source_type


class BinaryReader(FormatReader, ABC):
    wrapped_creation_func: Optional[type] = None


class CachingReader(BinaryReader, ABC):

    def load_source(
            self,
            source: Union[PathLike, HasRead],
            font_size: int = 16,
            provided_glyphs: Optional[Iterable[str]] = None
    ) -> RasterFont:
        stream = SeekableBinaryFileCopy.copy(source)
        original_path = stream.filename

        raw_font = load_and_cache_bitmap_font(
            source, self.wrapped_creation_func, cache=self.cache)
        actual_path = getattr(raw_font, 'file')
        provided_glyphs = self.cache[original_path].provided_glyphs
        raw_glyphs = copy_glyphs(raw_font, provided_glyphs)
        result = RasterFont(raw_glyphs, size_points=font_size, path=actual_path)
        return result


class TextFontReader(FormatReader):
    wrapped_creation_func = TextFontFile

    def load_source(
        self, source: Union[PathLike, HasRead],
        font_size: int = 16,
        force_provided_glyphs: Optional[Iterable[str]] = None
    ) -> RasterFont:
        with StdOrFile(source, 'r') as file:
            raw_font = TextFontFile(file.raw)

        path = get_source_filesystem_path(source)
        provided_glyphs = raw_font.provided_glyphs
        raw_glyphs = copy_glyphs(raw_font, provided_glyphs)

        return RasterFont(raw_glyphs, path=path)


class TrueTypeReader(BinaryReader):
    format_name = 'truetype'
    file_extensions = ['ttf']
    wrapped_creation_func = ImageFont.truetype

    def load_source(
            self, source: Union[PathLike, HasRead],
            font_size: int = 16,
            force_provided_glyphs: Optional[Iterable[str]] = None
    ) -> RasterFont:
        if force_provided_glyphs is None:
            force_provided_glyphs = generate_glyph_sequence()
        with StdOrFile(source, 'rb') as wrapped:
            raw_font = self.__class__.wrapped_creation_func(wrapped.raw)
            path = get_source_filesystem_path(source)

        raw_glyph_table = copy_glyphs(raw_font, glyphs=force_provided_glyphs)
        raster_font = RasterFont(
            glyph_table=raw_glyph_table,
            size_points=font_size,
            path=path
        )
        return raster_font


class BDFReader(CachingReader):
    format_name = 'bdf'
    wrapped_creation_func = BdfFontFile


class PCFReader(CachingReader):
    format_name = 'pcf'
    wrapped_creation_func = PcfFontFile
