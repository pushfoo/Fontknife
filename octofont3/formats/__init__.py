from abc import ABC, abstractmethod
from inspect import isabstract
from pathlib import Path
from typing import Optional, Iterable, Union, Callable, Dict, Set, Type

from PIL import ImageFont
from PIL.BdfFontFile import BdfFontFile
from PIL.PcfFontFile import PcfFontFile

from octofont3.custom_types import HasRead, PathLike, StreamOrPathLike
from octofont3.font_adapter import CachingFontAdapter
from octofont3.formats.caching import get_cache, load_and_cache_bitmap_font
from octofont3.formats.textfont.parser import TextFontFile
from octofont3.iohelpers import SeekableBinaryFileCopy, get_source_filesystem_path, absolute_path, StdOrFile


class FormatReader(ABC):

    # Track valid readers
    by_format_name: Dict[str, Type["FormatReader"]] = {}
    by_file_extension: Dict[str, Type["FormatReader"]] = {}
    file_extension_to_format_name: Dict[str, str] = {}
    file_extensions_for_class: Dict[type, Set[str]] = {}

    def __init_subclass__(cls):
        """
        Register every non-abstract subclass for easy access.

        This uses the attributes of subclasses instead of
        __init_subclass__ arguments because ABC appears to be
        incompatible in current python versions.

        The following subclass attributes are supported:
            1. ``wrapped_creation_func`` Mandatory for registration,
               optional for ABCs. A creation function or type wrapped
               by the subclass.
            1. ``format_name`` overrides auto-generation of format name
            2. ``file_extension`` overrides auto-generation of file
                extensions.

        If ``format_name`` is None or empty, it will be generated by:

            1. Converting the class name to lower case
            2. Removing 'reader' from the end of the name if present

        ``file_extensions`` will be handled as follows:

            1. Use the ``file_extensions`` class attribute if it
               exists, otherwise use the format name.
            2. If the current candidate is a string, use it to create
               a 1-length set. Otherwise, convert the iterable to a
               set.
            3. Use the set to fill ``by_file_extension`` and
               ``file_extensions_for_class``.

        The reader classes can then be retrieved by their associated
        format names and file extensions.
       """

        # Don't register abstract classes
        if isabstract(cls):
            return

        # Return if a wrapped_creation_func was not specified
        wrapped = getattr(cls, 'wrapped_creation_func', None)
        if not wrapped:
            return
        elif not callable(wrapped):
            raise TypeError('wrapped_creation_func must be a type or factory method for non-abstract classes!')

        format_name = getattr(cls, 'format_name', None)
        if not format_name:
            format_name = cls.__name__.lower().replace('reader', '')

        cls.by_format_name[format_name] = cls

        file_extensions = getattr(cls, 'file_extensions', None)
        if not file_extensions:
            file_extensions = (format_name,)
        if isinstance(file_extensions, str):
            file_extensions = (file_extensions,)
        file_extensions = set(file_extensions)

        cls.file_extensions_for_class[cls] = file_extensions
        for extension in file_extensions:
            cls.by_file_extension[extension] = cls
            cls.file_extension_to_format_name[extension] = format_name

    def __init__(self, caching_strategy: Callable = get_cache):
        self.cache = caching_strategy()

    @abstractmethod
    def load_source(
            self, source: Union[PathLike, HasRead],
            force_provided_glyphs: Optional[Iterable[str]] = None
    ) -> CachingFontAdapter:
        pass


def guess_path_type(path: Optional[PathLike]) -> Optional[str]:

    if path is None:
        return None

    path = Path(path)
    if not path.suffix:
        return 'spritedir' if path.is_dir() else None

    extension = path.suffix[1:]
    path_type = FormatReader.file_extension_to_format_name.get(extension, None)
    return path_type


def guess_source_path_type(source: StreamOrPathLike) -> Optional[str]:
    source_path = get_source_filesystem_path(source)
    source_type = guess_path_type(source_path)
    return source_type


class BinaryReader(FormatReader, ABC):
    # This must be specified by subclasses
    wrapped_creation_func: Optional[type] = None

    def load_source(
            self, source: Union[PathLike, HasRead],
            provided_glyphs: Optional[Iterable[str]] = None
    ) -> CachingFontAdapter:
        actual_load_path, provided_glyphs, raw_font = self.wrapped_creation_func(source)
        return CachingFontAdapter(
            raw_font,
            provided_glyphs=provided_glyphs,
            path=actual_load_path)


class CachingReader(BinaryReader, ABC):

    def load_source(
            self,
            source: Union[PathLike, HasRead],
            provided_glyphs: Optional[Iterable[str]] = None
    ) -> CachingFontAdapter:
        stream = SeekableBinaryFileCopy.copy(source)
        original_path = stream.filename

        raw_font = load_and_cache_bitmap_font(
            source, self.wrapped_creation_func, cache=self.cache)
        actual_path = getattr(raw_font, 'file')
        provided_glyphs = self.cache[original_path].provided_glyphs

        result = CachingFontAdapter(
            raw_font,
            provided_glyphs=provided_glyphs,
            path=actual_path
        )
        return result


class TextFontReader(FormatReader):
    wrapped_creation_func = TextFontFile

    def load_source(
            self, source: Union[PathLike, HasRead],
            force_provided_glyphs: Optional[Iterable[str]] = None
    ) -> CachingFontAdapter:
        with StdOrFile(source, 'r') as file:
            raw_font = TextFontFile(file.raw)

        path = get_source_filesystem_path(source)
        provided_glyphs = raw_font.provided_glyphs

        return CachingFontAdapter(
            raw_font,
            provided_glyphs=provided_glyphs,
            path=path)


class TrueTypeReader(BinaryReader):
    format_name = 'truetype'
    file_extensions = ['ttf']
    wrapped_creation_func = ImageFont.truetype


class BDFReader(CachingReader):
    format_name = 'bdf'
    wrapped_creation_func = BdfFontFile


class PCFReader(CachingReader):
    format_name = 'pcf'
    wrapped_creation_func = PcfFontFile
