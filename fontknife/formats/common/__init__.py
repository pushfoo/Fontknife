"""
Functionality common to multiple formats.

This includes:

    * Base classes for general format handlers, readers, and writers
    * Convenience classes covering binary IO & caching via pilfonts
    * Errors related to reading & writing

"""
# 3.7 compatibility for referencing a class within its own definition
from __future__ import annotations

import re
from abc import ABC, abstractmethod
from pathlib import Path
from typing import Dict, Type, Set, Callable, Optional, Iterable

from fontknife.custom_types import PathLike, PathLikeOrHasRead, PathLikeOrHasWrite, PathLikeOrHasStreamFunc, \
    BytesLike
from fontknife.formats.common.caching import get_cache, load_and_cache_bitmap_font
from fontknife.formats.common.raster_font import RasterFont, rasterize_font_to_tables
from fontknife.iohelpers import get_resource_filesystem_path, SeekableBinaryFileCopy

# Matches capitalized words in class names
PASCAL_CASE_WORD_REGEX = re.compile(r'[A-Z][a-z]*')


def __init_subclass__(cls: Type["FormatHandlerRegistryABC"]):
    """
    Subclass initializer for format handlers.

    When assigned as the ``__init_subclass__`` method of a class, this
    function ignores any subclass with ABC as an immediate baseclass.
    Otherwise, it will attempt to calculate metadata. If successful, it
    will use it to register the subclass in the parent's lookup tables.

    We use this approach because ABCs preclude using another metaclass.
    You can only have one metaclass, and ABC is already shorthand for
    ``class ABC(metaclass=ABCMeta):``. It may be possible to write a
    proxy type that composes metaclasses, but it would be more work than
    this approach.

    The following optional subclass attributes are supported:
        1. ``wrapped_callable``: a handler callable used by the format
        1. ``format``: overrides auto-generation of format name
        2. ``file_extension``: overrides auto-generation of file
            extensions.

    If ``format`` is None or empty, it will be generated by:

        2. Removing  'Reader' or 'Writer' from the class name if present
        2. Converting the result to lower case

    ``file_extensions`` will be handled as follows:

        1. Use the ``file_extensions`` class attribute if it
           exists, otherwise use the format name.
        2. If the current candidate is a string, use it to create
           a 1-length set. Otherwise, convert the iterable to a
           set.
        3. Use the set to fill ``by_file_extension`` and
           ``file_extensions_for_class``.

    The handler subclasses can be retrieved by their associated
    format names and file extensions through the class methods
    of their base format handler registries
    """
    # Skip anything that has ABC as an immediate base class
    if ABC in cls.__bases__:
        return

    # If wrapped_callable is defined, make sure it's callable
    wrapped = getattr(cls, 'wrapped_callable', None)
    if wrapped is not None and not callable(wrapped):
        raise TypeError('wrapped_callable must be a callable!')

    # Use a specified format if it was given
    format_name = getattr(cls, 'format', None)

    if not format_name:
        # Remove strippable words from the end & convert to lower case
        name_parts = PASCAL_CASE_WORD_REGEX.findall(cls.__name__)
        if name_parts[-1] in ('Reader', 'Writer'):
            name_parts.pop()
        format_name = ''.join(name_parts).lower()

    cls.by_format_name[format_name] = cls

    # Use format as an extension if no extensions are specified
    file_extensions = getattr(cls, 'file_extensions', None)
    if not file_extensions:
        file_extensions = (format_name,)
    elif isinstance(file_extensions, str):
        file_extensions = (file_extensions,)
    file_extensions = set(file_extensions)

    # Register the format and extensions for the reader
    cls._file_extensions_for_format_name[format_name] = file_extensions
    for extension in file_extensions:
        cls._by_file_extension[extension] = cls
        cls._file_extension_to_format_name[extension] = format_name


class FormatHandlerRegistryABC(ABC):
    """
    Base class for all format registries.

    All immediate subclasses will be handler registries. Handler
    registries store information about any subclass of theirs which
    does not have ABC as an immediate baseclass.

    This is a workaround for the limitations of Python. See the
    ``__init_subclass__`` function at the top of this file for more
    information, including:

        * What registration means
        * What class attributes are supported for modifying registration
        * Why keyword arguments to class initialization aren't allowed

    """

    # These entries exist for the benefit of type checkers &
    # autocompletion. They will be replaced by subclass-specific
    # attributes on subclass instantiation.
    by_format_name: Dict[str, Type[FormatHandlerRegistryABC]] = {}
    _by_file_extension: Dict[str, Type[FormatHandlerRegistryABC]] = {}
    _file_extension_to_format_name: Dict[str, str] = {}
    _file_extensions_for_format_name: Dict[str, Set[str]] = {}

    def __init_subclass__(cls):

        # Replace __init_subclass__ to turn cls into a handler registry
        cls.__init_subclass__ = classmethod(__init_subclass__)

        # Create tables local to the handler registry
        cls.by_format_name = {}
        cls._by_file_extension = {}
        cls._file_extension_to_format_name = {}
        cls._file_extensions_for_format_name = {}

    @classmethod
    def guess_path_format_name(cls: Type[FormatHandlerRegistryABC], path: PathLike) -> Optional[str]:
        if path is None:
            return None

        path = Path(path)
        if not path.suffix:
            return 'spritedir' if path.is_dir() else None

        extension = path.suffix[1:]
        path_type = cls._file_extension_to_format_name.get(extension, None)
        return path_type

    @classmethod
    def guess_format_name(cls: Type[FormatHandlerRegistryABC], resource: PathLikeOrHasStreamFunc) -> Optional[str]:
        resource_path = get_resource_filesystem_path(resource)
        resource_format_name = cls.guess_path_format_name(resource_path)
        return resource_format_name

    @classmethod
    def guess_format(
        cls: Type[FormatHandlerRegistryABC],
        resource: PathLikeOrHasStreamFunc
    ) -> Optional[Type[FormatHandlerRegistryABC]]:
        return cls.by_format_name.get(cls.guess_format_name(resource), None)


class FormatReader(FormatHandlerRegistryABC, ABC):

    def __init__(self, caching_strategy: Callable = get_cache):
        """
        Baseclass for all font format readers.

        These classes handle loading from a file to a RasterFont.
        :param caching_strategy:
        """
        self.cache = caching_strategy()

    @abstractmethod
    def load_source(
        self,
        source: PathLikeOrHasRead,
        format: str,
        **kwargs
    ) -> RasterFont:
        pass


class FormatWriter(FormatHandlerRegistryABC, ABC):
    """
    Baseclass for all font format writers.

    These handle writing from a RasterFont to a file.
    """

    @abstractmethod
    def write_output(
        self,
        font: RasterFont,
        destination: PathLikeOrHasWrite,
        glyph_sequence: Optional[Iterable[str]] = None,
        **kwargs
    ) -> RasterFont:
        pass


class BinaryReader(FormatReader, ABC):
    """
    Base class for any binary format reader.
    """
    wrapped_callable: Optional[type] = None


class CachingReader(BinaryReader, ABC):
    """
    Used for files that are cached to pilfont format.

    Pillow does not support direct loading of certain formats, but
    instead provides a way to convert them to an internal format called
    pilfont. This class handles caching the intermediary, and requires
    the ``wrapped_callable`` class attribute to be defined for any
    subclass.

    Do not rely on this class. It may be removed in the future if better
    loading approaches are added.
    """
    def load_source(
        self,
        source: PathLikeOrHasRead[BytesLike],
        font_size: int = 16,
        force_provided_glyphs: Optional[Iterable[str]] = None,
        **kwargs
    ) -> RasterFont:
        stream = SeekableBinaryFileCopy.copy(source)
        original_path = stream.filename

        raw_font = load_and_cache_bitmap_font(
            source, self.wrapped_callable, cache=self.cache)
        actual_path = getattr(raw_font, 'file')
        force_provided_glyphs = self.cache[original_path].provided_glyphs
        raw_glyph_data = rasterize_font_to_tables(raw_font, force_provided_glyphs)
        result = RasterFont(**raw_glyph_data, size_points=font_size, path=actual_path)
        return result


